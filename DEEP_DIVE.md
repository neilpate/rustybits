# Deep Dive: From Rust Code to Running micro:bit

This document explains the detailed process of how Rust code becomes a running program on the BBC micro:bit v2, covering compilation, linking, memory layout, and flashing.

## Overview

The journey from Rust source to running embedded code involves several critical steps:

1. **Cross-compilation** to ARM Cortex-M4 assembly
2. **Linking** with memory layout and runtime components  
3. **Binary generation** in ELF format
4. **Flashing** to the nRF52833 microcontroller via probe-rs

## Step 1: Cross-Compilation

### Target Architecture
```toml
# .cargo/config.toml
target = "thumbv7em-none-eabihf"
```

This specifies:
- **`thumbv7em`**: ARMv7E-M architecture (Cortex-M4/M7 with DSP extensions)
- **`none`**: No operating system (bare metal)
- **`eabihf`**: Embedded Application Binary Interface with Hardware Floating Point

### Compilation Process
```bash
rustc --target thumbv7em-none-eabihf --crate-type bin src/main.rs
```

The Rust compiler:
1. **Parses** Rust source code into an Abstract Syntax Tree (AST)
2. **Type checks** and performs borrow checking
3. **Generates** LLVM Intermediate Representation (IR)
4. **Optimizes** the IR for size and speed (embedded targets prefer size)
5. **Outputs** ARM Thumb-2 assembly code
6. **Assembles** to object files (.o)

## Step 2: Memory Layout Configuration

### Linker Script Generation
The `microbit-v2` crate generates a `memory.x` file during build:

```linker-script
MEMORY
{
  /* nRF52833 memory layout */
  FLASH : ORIGIN = 0x00000000, LENGTH = 512K
  RAM   : ORIGIN = 0x20000000, LENGTH = 128K
}
```

### Runtime Components
The `cortex-m-rt` crate provides:

```rust
// Startup sequence (simplified)
#[no_mangle]
pub unsafe extern "C" fn Reset() {
    // 1. Initialize RAM
    // 2. Set up stack pointer
    // 3. Copy .data section from flash to RAM
    // 4. Zero .bss section
    // 5. Call main()
}
```

## Step 3: Linking Process

### Linker Invocation
```bash
rust-lld \
  -flavor gnu \
  -Tlink.x \           # Cortex-M runtime linker script
  -Tmemory.x \         # Memory layout
  --gc-sections \      # Remove unused code
  -o target.elf \
  main.o cortex_m_rt.o microbit_v2.o ...
```

### Memory Sections
The linker organizes code into sections:

```
Flash (0x00000000 - 0x0007FFFF):
├── .vector_table    # Interrupt vectors (@ 0x00000000)
├── .text           # Program code
├── .rodata         # Read-only data (strings, constants)
└── .data (initial) # Initial values for RAM variables

RAM (0x20000000 - 0x2001FFFF):
├── .data           # Initialized variables (copied from flash)
├── .bss            # Zero-initialized variables
├── .uninit         # Uninitialized variables
└── Stack           # Grows downward from top of RAM
```

### Critical Linking Elements

**Vector Table** (first 256 bytes of flash):
```rust
// Generated by cortex-m-rt
#[link_section = ".vector_table.reset_vector"]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern "C" fn() -> ! = Reset;
```

**Entry Point**:
```rust
#[entry] // Macro from cortex-m-rt
fn main() -> ! {
    // Your code here
}
// Expands to proper reset handler setup
```

## Step 4: Binary Generation

### ELF Output
The linker produces an ELF (Executable and Linkable Format) file containing:
- **Headers**: Architecture, entry point, section locations
- **Program sections**: Code and data with load addresses  
- **Symbol table**: Function and variable names for debugging
- **Debug info**: Source line mappings (if enabled)

### Verification
```bash
# Check the binary structure
arm-none-eabi-objdump -h target.elf
arm-none-eabi-size target.elf

# Typical output:
# text    data     bss     dec     hex filename
# 8432     108    2048   10588    295c target.elf
```

## Step 5: Flashing with probe-rs

### micro:bit Hardware Architecture

The BBC micro:bit v2 contains **two separate microcontrollers**:

1. **Target MCU**: nRF52833 (Nordic ARM Cortex-M4) - runs your Rust code
2. **Interface MCU**: nRF52820 (also Nordic ARM Cortex-M4) - acts as debug probe

```
PC ←→ USB ←→ nRF52820 (Interface) ←→ SWD ←→ nRF52833 (Target)
                │                              │
         [Debug Firmware]              [Your Rust Code]
```

### Interface MCU Functions
The nRF52820 interface chip provides:
- **USB-to-SWD bridge**: Converts USB commands to Serial Wire Debug protocol
- **Virtual COM port**: For serial communication with your program
- **Mass storage device**: Drag-and-drop .hex file programming (alternative to probe-rs)
- **WebUSB interface**: Browser-based programming support

### probe-rs Architecture
```
PC (probe-rs) ←→ USB ←→ nRF52820 Interface ←→ SWD ←→ nRF52833 Target
```

When you run `cargo run`, probe-rs:
1. **Connects via USB** to the nRF52820 interface chip
2. **Sends debug commands** over a proprietary protocol  
3. **Interface chip translates** these to SWD signals
4. **Target chip responds** via SWD back through the interface

This is different from external debug probes (J-Link, ST-Link) where the probe is separate hardware.

### Connection Process
1. **USB enumeration**: PC detects micro:bit as USB device (VID: 0x0d28, PID: 0x0204)
2. **Interface identification**: probe-rs recognizes the nRF52820 debug firmware
3. **Target discovery**: Interface chip scans for connected nRF52833 via SWD
4. **Debug session**: Establishes communication channel to target processor


### Flash Memory Layout After Programming
```
nRF52833 Flash (512KB):
0x00000000: ┌─ Vector Table ────────────┐
0x00000100: ├─ Reset Handler ──────────┤  
0x00000200: ├─ Main Program Code ──────┤
0x00002000: ├─ Constant Data ──────────┤
0x00002100: ├─ Initial RAM Values ─────┤
0x00002200: ├─ (unused) ───────────────┤
            │                          │
0x0007FFFF: └──────────────────────────┘
```

## Debug Interface Details

### SWD (Serial Wire Debug) Protocol

SWD is ARM's proprietary debugging protocol, designed as a more efficient alternative to JTAG for ARM Cortex-M processors.

#### Physical Interface
- **SWCLK**: Serial Wire Clock - provides timing for data transfers
- **SWDIO**: Serial Wire Data I/O - bidirectional data line
- **Ground**: Common reference
- **VCC**: Power reference (3.3V on micro:bit)

#### Protocol Stack
```
Application (probe-rs) 
       ↕
Debug Port (DP) - Controls the debug interface
       ↕  
Access Port (AP) - Provides memory access
       ↕
Target Memory Bus - CPU's internal buses
```

#### How SWD Works


#### Debug Features Enabled by SWD
- **Flash Programming**: Direct write access to flash memory controllers
- **Memory Inspection**: Read any RAM/peripheral register in real-time
- **CPU Control**: Halt, reset, single-step execution
- **Breakpoints**: Set hardware breakpoints (nRF52833 has 6 hardware breakpoints)
- **Watchpoints**: Monitor memory locations for read/write access
- **Real-time Trace**: Extract execution trace data (if supported by target)

#### SWD vs JTAG Comparison
| Feature | SWD | JTAG |
|---------|-----|------|
| Pins | 2 (+ power/ground) | 4 (+ power/ground) |
| Speed | Up to 50MHz | Up to 25MHz typical |
| Complexity | Simpler protocol | More complex state machine |
| ARM Support | Native ARM protocol | Generic standard |
| Trace | Supports SWO trace | Supports ETM trace |

#### Security and SWD
Modern ARM processors (including nRF52833) support:
- **Debug Authentication**: Cryptographic authentication before debug access
- **Secure Debug**: Different privilege levels for debug access  
- **Access Port Protection**: Fine-grained control over memory regions
- **Debug Disable**: Complete disabling of debug interface for production

### probe-rs Capabilities
```bash
# List connected probes
probe-rs list

# Flash and run
probe-rs run --chip nRF52833_xxAA target.elf

# Interactive debugging
probe-rs gdb --chip nRF52833_xxAA target.elf

# Real-time tracing (if supported)
probe-rs rtt --chip nRF52833_xxAA target.elf
```

## Performance Considerations

### Code Size Optimization
```toml
# Cargo.toml optimizations for embedded
[profile.release]
opt-level = "s"     # Optimize for size
lto = true          # Link-time optimization
codegen-units = 1   # Single codegen unit for better optimization
panic = "abort"     # Smaller panic handler
```

### Memory Usage
- **Flash**: Typically 4-20KB for simple examples
- **RAM**: Static allocation preferred (no heap allocator)
- **Stack**: Usually 2-8KB depending on recursion depth
