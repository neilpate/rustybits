# Deep Dive: From Rust Code to Running micro:bit

This document explains the detailed process of how Rust code becomes a running program on the BBC micro:bit v2, covering compilation, linking, memory layout, and flashing.

## Overview

The journey from Rust source to running embedded code involves several critical steps:

1. **Cross-compilation** to ARM Cortex-M4 assembly
2. **Linking** with memory layout and runtime components  
3. **Binary generation** in ELF format
4. **Flashing** to the nRF52833 microcontroller via probe-rs

## Step 1: Cross-Compilation

### Target Architecture
```toml
# .cargo/config.toml
target = "thumbv7em-none-eabihf"
```

This specifies:
- **`thumbv7em`**: ARMv7E-M architecture (Cortex-M4/M7 with DSP extensions)
- **`none`**: No operating system (bare metal)
- **`eabihf`**: Embedded Application Binary Interface with Hardware Floating Point

### Compilation Process
```bash
rustc --target thumbv7em-none-eabihf --crate-type bin src/main.rs
```

The Rust compiler:
1. **Parses** Rust source code into an Abstract Syntax Tree (AST)
2. **Type checks** and performs borrow checking
3. **Generates** LLVM Intermediate Representation (IR)
4. **Optimizes** the IR for size and speed (embedded targets prefer size)
5. **Outputs** ARM Thumb-2 assembly code
6. **Assembles** to object files (.o)

## Step 2: Memory Layout Configuration

### Linker Script Generation
The `microbit-v2` crate generates a `memory.x` file during build:

```linker-script
MEMORY
{
  /* nRF52833 memory layout */
  FLASH : ORIGIN = 0x00000000, LENGTH = 512K
  RAM   : ORIGIN = 0x20000000, LENGTH = 128K
}
```

### Runtime Components
The `cortex-m-rt` crate provides:

```rust
// Startup sequence (simplified)
#[no_mangle]
pub unsafe extern "C" fn Reset() {
    // 1. Initialize RAM
    // 2. Set up stack pointer
    // 3. Copy .data section from flash to RAM
    // 4. Zero .bss section
    // 5. Call main()
}
```

## Step 3: Linking Process

### Linker Invocation
```bash
rust-lld \
  -flavor gnu \
  -Tlink.x \           # Cortex-M runtime linker script
  -Tmemory.x \         # Memory layout
  --gc-sections \      # Remove unused code
  -o target.elf \
  main.o cortex_m_rt.o microbit_v2.o ...
```

### Memory Sections
The linker organizes code into sections:

```
Flash (0x00000000 - 0x0007FFFF):
├── .vector_table    # Interrupt vectors (@ 0x00000000)
├── .text           # Program code
├── .rodata         # Read-only data (strings, constants)
└── .data (initial) # Initial values for RAM variables

RAM (0x20000000 - 0x2001FFFF):
├── .data           # Initialized variables (copied from flash)
├── .bss            # Zero-initialized variables
├── .uninit         # Uninitialized variables
└── Stack           # Grows downward from top of RAM
```

### Critical Linking Elements

**Vector Table** (first 256 bytes of flash):
```rust
// Generated by cortex-m-rt
#[link_section = ".vector_table.reset_vector"]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern "C" fn() -> ! = Reset;
```

**Entry Point**:
```rust
#[entry] // Macro from cortex-m-rt
fn main() -> ! {
    // Your code here
}
// Expands to proper reset handler setup
```

## Step 4: Binary Generation

### ELF Output
The linker produces an ELF (Executable and Linkable Format) file containing:
- **Headers**: Architecture, entry point, section locations
- **Program sections**: Code and data with load addresses  
- **Symbol table**: Function and variable names for debugging
- **Debug info**: Source line mappings (if enabled)

### Verification
```bash
# Check the binary structure
arm-none-eabi-objdump -h target.elf
arm-none-eabi-size target.elf

# Typical output:
# text    data     bss     dec     hex filename
# 8432     108    2048   10588    295c target.elf
```

## Step 5: Flashing with probe-rs

### probe-rs Architecture
```
PC (probe-rs) ←→ Debug Probe ←→ SWD Interface ←→ nRF52833
```

### Connection Process
1. **Probe detection**: probe-rs scans for connected debug probes (J-Link, ST-Link, etc.)
2. **Target identification**: Reads the chip's IDCODE to confirm it's an nRF52833
3. **Debug interface**: Establishes SWD (Serial Wire Debug) connection
4. **Halt CPU**: Stops the processor to allow memory access

### Flashing Sequence

```rust
// Simplified probe-rs flashing process
fn flash_target(elf_path: &str) -> Result<()> {
    // 1. Parse ELF file
    let elf = ElfFile::parse(&fs::read(elf_path)?)?;
    
    // 2. Connect to target
    let mut session = Session::auto_attach("nRF52833_xxAA")?;
    
    // 3. Halt the core
    let mut core = session.core(0)?;
    core.halt()?;
    
    // 4. Erase required flash sectors
    session.target().flash_loader().erase_sectors(sectors)?;
    
    // 5. Program flash memory
    for segment in elf.program_iter() {
        if segment.get_type() == Ok(Type::Load) {
            let data = segment.get_data(&elf)?;
            session.target().flash_loader().program_page(
                segment.physical_addr(),
                data
            )?;
        }
    }
    
    // 6. Verify programming
    session.target().flash_loader().verify()?;
    
    // 7. Reset and run
    core.reset_and_halt()?;
    core.run()?;
}
```

### Flash Memory Layout After Programming
```
nRF52833 Flash (512KB):
0x00000000: ┌─ Vector Table ────────────┐
0x00000100: ├─ Reset Handler ──────────┤  
0x00000200: ├─ Main Program Code ──────┤
0x00002000: ├─ Constant Data ──────────┤
0x00002100: ├─ Initial RAM Values ─────┤
0x00002200: ├─ (unused) ───────────────┤
            │                          │
0x0007FFFF: └──────────────────────────┘
```

## Debug Interface Details

### SWD (Serial Wire Debug)
- **2-wire interface**: SWCLK (clock) and SWDIO (data)
- **Access ports**: Debug Port (DP) and Access Port (AP)
- **Memory access**: Can read/write any location in the CPU's memory map
- **Breakpoints**: Hardware breakpoint units for debugging

### probe-rs Capabilities
```bash
# List connected probes
probe-rs list

# Flash and run
probe-rs run --chip nRF52833_xxAA target.elf

# Interactive debugging
probe-rs gdb --chip nRF52833_xxAA target.elf

# Real-time tracing (if supported)
probe-rs rtt --chip nRF52833_xxAA target.elf
```

## Performance Considerations

### Code Size Optimization
```toml
# Cargo.toml optimizations for embedded
[profile.release]
opt-level = "s"     # Optimize for size
lto = true          # Link-time optimization
codegen-units = 1   # Single codegen unit for better optimization
panic = "abort"     # Smaller panic handler
```

### Memory Usage
- **Flash**: Typically 4-20KB for simple examples
- **RAM**: Static allocation preferred (no heap allocator)
- **Stack**: Usually 2-8KB depending on recursion depth

## Common Issues and Solutions

### Linker Errors
```
error: linking with `rust-lld` failed: exit status: 1
  = note: rust-lld: error: undefined symbol: main
```
**Solution**: Ensure `#[entry]` macro is used instead of regular `fn main()`

### Memory Overflow
```
error: FLASH will not fit in region 'FLASH'
  FLASH overflowed by 1024 bytes
```
**Solution**: Enable release optimizations or reduce code size

### Probe Connection Issues
```
Error: Connecting to chip was unsuccessful
Caused by: Target device did not respond
```
**Solutions**:
- Check USB connection
- Verify micro:bit is in programming mode
- Try different USB cable/port
- Check probe-rs supported devices

## Conclusion

This process transforms high-level Rust code into a bare-metal embedded program through careful orchestration of:
- Cross-compilation targeting ARM Cortex-M4
- Memory-aware linking with embedded constraints  
- Precise flash programming via debug interfaces
- Hardware-specific initialization and runtime support

The beauty of the Rust embedded ecosystem is that most of this complexity is hidden behind ergonomic APIs, allowing developers to focus on application logic rather than low-level hardware details.